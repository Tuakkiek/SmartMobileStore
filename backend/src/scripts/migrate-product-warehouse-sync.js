import dotenv from "dotenv";
import mongoose from "mongoose";
import UniversalProduct from "../modules/product/UniversalProduct.js";
import ProductType from "../modules/productType/ProductType.js";
import "../modules/brand/Brand.js";
import WarehouseConfiguration from "../modules/warehouse/WarehouseConfiguration.js";
import WarehouseLocation from "../modules/warehouse/WarehouseLocation.js";
import Inventory from "../modules/warehouse/Inventory.js";
import User from "../modules/auth/User.js";
import {
  classifyProductTypeSlug,
  normalizeWarehouseCategory,
  getWarehouseCategoryLabels,
} from "../lib/productClassification.js";

dotenv.config();

const LOG_PREFIX = "[MIGRATE][PRODUCT_WAREHOUSE]";

const getArgValue = (args, key, fallback = null) => {
  const prefix = `${key}=`;
  const hit = args.find((arg) => arg.startsWith(prefix));
  if (!hit) return fallback;
  return hit.slice(prefix.length);
};

const toInt = (value, fallback) => {
  if (value === undefined || value === null) return fallback;
  if (String(value).trim() === "") return fallback;
  const num = Number(value);
  if (!Number.isFinite(num)) return fallback;
  return Math.max(1, Math.floor(num));
};

const parseOptions = (args) => {
  const dryRun = args.includes("--dry-run");
  const skipInventorySync = args.includes("--skip-inventory-sync");

  const warehouseCodeInput =
    getArgValue(args, "--warehouse-code", process.env.WAREHOUSE_MIGRATION_CODE || "WH-ALL") ||
    "WH-ALL";
  const warehouseCode = warehouseCodeInput.toUpperCase();

  if (!/^WH-[A-Z]{2,10}$/.test(warehouseCode)) {
    throw new Error(`Invalid warehouse code "${warehouseCode}". Expected format WH-XXX`);
  }

  return {
    dryRun,
    skipInventorySync,
    resetWarehouseInventory: true,
    warehouseCode,
    warehouseName:
      getArgValue(args, "--warehouse-name", process.env.WAREHOUSE_MIGRATION_NAME) ||
      "Unified Product Warehouse",
    warehouseAddress:
      getArgValue(args, "--warehouse-address", process.env.WAREHOUSE_MIGRATION_ADDRESS) ||
      "Auto-generated by product + warehouse sync migration",
    capacityPerBin: toInt(
      getArgValue(args, "--capacity-per-bin", process.env.WAREHOUSE_MIGRATION_CAPACITY_PER_BIN),
      100
    ),
    shelvesPerAisle: toInt(
      getArgValue(
        args,
        "--shelves-per-aisle",
        process.env.WAREHOUSE_MIGRATION_SHELVES_PER_AISLE
      ),
      10
    ),
    binsPerShelf: toInt(
      getArgValue(args, "--bins-per-shelf", process.env.WAREHOUSE_MIGRATION_BINS_PER_SHELF),
      20
    ),
    maxAisles: 99,
  };
};

const connectDB = async () => {
  const uri = process.env.MONGODB_CONNECTIONSTRING || process.env.MONGO_URI;
  if (!uri) {
    throw new Error("Missing MONGODB_CONNECTIONSTRING or MONGO_URI");
  }

  await mongoose.connect(uri);
  console.log(`${LOG_PREFIX} MongoDB connected`);
};

const toObjectIdString = (value) => {
  if (!value) return "";
  if (typeof value === "string") return value;
  if (typeof value.toString === "function") return value.toString();
  return String(value);
};

const buildZoneCode = (index) => {
  let code = "";
  let n = index;

  while (n >= 0) {
    code = String.fromCharCode(65 + (n % 26)) + code;
    n = Math.floor(n / 26) - 1;
  }

  return code;
};

const chunkArray = (items, size) => {
  const chunks = [];
  for (let i = 0; i < items.length; i += size) {
    chunks.push(items.slice(i, i + size));
  }
  return chunks;
};

const loadActiveTypeMap = async () => {
  const types = await ProductType.find({ status: "ACTIVE" })
    .select("_id name slug status")
    .lean();

  if (!types.length) {
    throw new Error("No active product types found");
  }

  const map = new Map();

  for (const type of types) {
    const normalizedSlug = normalizeWarehouseCategory(type.slug || type.name);
    if (!normalizedSlug) continue;
    if (!map.has(normalizedSlug)) {
      map.set(normalizedSlug, type);
    }
  }

  if (!map.size) {
    throw new Error("Could not build normalized product type map");
  }

  return map;
};

const loadProducts = async () =>
  UniversalProduct.find({})
    .select("_id name model productType brand variants")
    .populate("productType", "_id name slug")
    .populate("brand", "_id name")
    .populate("variants", "_id sku stock")
    .lean();

const planProductTypeUpdates = (products, typeBySlug) => {
  const updates = [];
  const unresolved = [];
  const resolvedMetaById = new Map();

  for (const product of products) {
    const currentTypeId = toObjectIdString(product.productType?._id || product.productType);
    const currentSlug = normalizeWarehouseCategory(
      product.productType?.slug || product.productType?.name || ""
    );

    const inferredSlug = classifyProductTypeSlug({
      name: product.name,
      model: product.model,
      brandName: product.brand?.name,
      currentSlug,
    });

    const resolvedSlug = inferredSlug && typeBySlug.has(inferredSlug) ? inferredSlug : currentSlug;
    const resolvedType = resolvedSlug ? typeBySlug.get(resolvedSlug) : null;

    if (!resolvedType) {
      unresolved.push({
        productId: toObjectIdString(product._id),
        productName: product.name,
        productModel: product.model,
        inferredSlug,
      });
      continue;
    }

    const targetTypeId = toObjectIdString(resolvedType._id);
    resolvedMetaById.set(toObjectIdString(product._id), {
      slug: resolvedSlug,
      typeId: targetTypeId,
      typeName: resolvedType.name,
    });

    if (!currentTypeId || currentTypeId !== targetTypeId) {
      updates.push({
        productId: toObjectIdString(product._id),
        productName: product.name,
        fromTypeId: currentTypeId,
        fromTypeSlug: currentSlug,
        toTypeId: targetTypeId,
        toTypeSlug: resolvedSlug,
        toTypeName: resolvedType.name,
      });
    }
  }

  return { updates, unresolved, resolvedMetaById };
};

const applyProductTypeUpdates = async (updates, dryRun) => {
  if (!updates.length) return 0;
  if (dryRun) return updates.length;

  const ops = updates.map((item) => ({
    updateOne: {
      filter: { _id: item.productId },
      update: { $set: { productType: item.toTypeId } },
    },
  }));

  const result = await UniversalProduct.bulkWrite(ops, { ordered: false });
  return result.modifiedCount || 0;
};

const buildNormalizedProductSnapshot = (products, resolvedMetaById) =>
  products.map((product) => {
    const id = toObjectIdString(product._id);
    const resolved = resolvedMetaById.get(id);
    const currentSlug = normalizeWarehouseCategory(
      product.productType?.slug || product.productType?.name || ""
    );

    return {
      _id: id,
      name: product.name,
      model: product.model,
      variants: Array.isArray(product.variants) ? product.variants : [],
      resolvedTypeSlug: resolved?.slug || currentSlug,
      resolvedTypeId:
        resolved?.typeId || toObjectIdString(product.productType?._id || product.productType),
      resolvedTypeName: resolved?.typeName || product.productType?.name || currentSlug || "Product",
    };
  });

const buildTypeStats = (products) => {
  const stats = new Map();

  for (const product of products) {
    const slug = product.resolvedTypeSlug;
    if (!slug) continue;

    if (!stats.has(slug)) {
      stats.set(slug, {
        slug,
        typeName: product.resolvedTypeName,
        productCount: 0,
        variantCount: 0,
        totalStock: 0,
      });
    }

    const row = stats.get(slug);
    row.productCount += 1;

    for (const variant of product.variants) {
      row.variantCount += 1;
      const qty = Math.max(0, Math.floor(Number(variant?.stock) || 0));
      row.totalStock += qty;
    }
  }

  return Array.from(stats.values()).sort((a, b) => {
    if (b.totalStock !== a.totalStock) return b.totalStock - a.totalStock;
    return a.slug.localeCompare(b.slug);
  });
};

const buildWarehouseZones = (typeStats, options) => {
  if (!typeStats.length) {
    return [
      {
        code: "GEN",
        name: "General Products",
        description: "Fallback zone for inventory placement",
        aisles: 1,
        shelvesPerAisle: options.shelvesPerAisle,
        binsPerShelf: options.binsPerShelf,
        capacityPerBin: options.capacityPerBin,
        productCategories: ["accessories", "smartphone", "tablet", "smartwatch"],
        status: "ACTIVE",
      },
    ];
  }

  const binsPerAisle = options.shelvesPerAisle * options.binsPerShelf;

  return typeStats.map((stat, index) => {
    const requiredBinsByStock = Math.ceil(stat.totalStock / options.capacityPerBin);
    const requiredBinsByVariants = Math.max(1, stat.variantCount);
    const requiredBins = Math.max(1, requiredBinsByStock, requiredBinsByVariants);
    const aisles = Math.min(options.maxAisles, Math.max(1, Math.ceil(requiredBins / binsPerAisle)));

    return {
      code: buildZoneCode(index),
      name: `Zone ${buildZoneCode(index)} - ${stat.typeName}`,
      description: `Auto-generated zone for ${stat.typeName} products`,
      aisles,
      shelvesPerAisle: options.shelvesPerAisle,
      binsPerShelf: options.binsPerShelf,
      capacityPerBin: options.capacityPerBin,
      productCategories: getWarehouseCategoryLabels(stat.slug, stat.typeName),
      status: "ACTIVE",
      notes: `products=${stat.productCount}, variants=${stat.variantCount}, stock=${stat.totalStock}`,
    };
  });
};

const resolveMigrationUser = async () => {
  const admin = await User.findOne({ role: "ADMIN" }).sort({ createdAt: 1 }).select("_id fullName").lean();
  if (admin) return admin;

  const anyUser = await User.findOne({}).sort({ createdAt: 1 }).select("_id fullName").lean();
  if (anyUser) return anyUser;

  return {
    _id: new mongoose.Types.ObjectId(),
    fullName: "System Migration",
  };
};

const upsertWarehouseConfig = async ({ options, zones, actor }) => {
  const existing = await WarehouseConfiguration.findOne({ warehouseCode: options.warehouseCode });

  if (options.dryRun) {
    return existing || null;
  }

  if (!existing) {
    const warehouse = new WarehouseConfiguration({
      warehouseCode: options.warehouseCode,
      name: options.warehouseName,
      address: options.warehouseAddress,
      zones,
      status: "ACTIVE",
      locationsGenerated: false,
      totalLocations: 0,
      createdBy: actor._id,
      createdByName: actor.fullName || "System Migration",
    });

    await warehouse.save();
    return warehouse;
  }

  existing.name = options.warehouseName;
  existing.address = options.warehouseAddress;
  existing.zones = zones;
  existing.status = "ACTIVE";
  existing.updatedBy = actor._id;
  existing.updatedByName = actor.fullName || "System Migration";
  await existing.save();
  return existing;
};

const buildLocationBlueprints = (warehouseCode, zones) => {
  const blueprints = [];

  for (const zone of zones) {
    for (let aisle = 1; aisle <= zone.aisles; aisle += 1) {
      for (let shelf = 1; shelf <= zone.shelvesPerAisle; shelf += 1) {
        for (let bin = 1; bin <= zone.binsPerShelf; bin += 1) {
          const locationCode = `${warehouseCode}-${zone.code}-${String(aisle).padStart(
            2,
            "0"
          )}-${String(shelf).padStart(2, "0")}-${String(bin).padStart(2, "0")}`;

          blueprints.push({
            locationCode,
            warehouse: warehouseCode,
            zone: zone.code,
            zoneName: zone.name,
            aisle: String(aisle).padStart(2, "0"),
            shelf: String(shelf).padStart(2, "0"),
            bin: String(bin).padStart(2, "0"),
            capacity: zone.capacityPerBin,
            status: zone.status || "ACTIVE",
            productCategories: zone.productCategories || [],
          });
        }
      }
    }
  }

  return blueprints;
};

const syncWarehouseLocations = async ({ warehouseConfig, zones, actor, options }) => {
  const blueprints = buildLocationBlueprints(options.warehouseCode, zones);

  if (options.dryRun) {
    return {
      expectedLocations: blueprints.length,
      insertedLocations: 0,
      removedLocations: 0,
      updatedLocations: 0,
      locations: [],
    };
  }

  const blueprintCodeSet = new Set(blueprints.map((bp) => bp.locationCode));
  const existingLocations = await WarehouseLocation.find({ warehouse: options.warehouseCode })
    .select("_id locationCode")
    .lean();

  const staleLocations = existingLocations.filter(
    (loc) => !blueprintCodeSet.has(loc.locationCode)
  );
  if (staleLocations.length > 0) {
    const staleIds = staleLocations.map((loc) => loc._id);
    await Inventory.deleteMany({ locationId: { $in: staleIds } });
    await WarehouseLocation.deleteMany({ _id: { $in: staleIds } });
  }

  const existingCodeSet = new Set(
    existingLocations
      .filter((loc) => blueprintCodeSet.has(loc.locationCode))
      .map((loc) => loc.locationCode)
  );

  const toInsert = blueprints.filter((bp) => !existingCodeSet.has(bp.locationCode));
  if (toInsert.length > 0) {
    await WarehouseLocation.insertMany(toInsert, { ordered: false });
  }

  const updateOps = blueprints.map((bp) => ({
    updateOne: {
      filter: { locationCode: bp.locationCode },
      update: {
        $set: {
          warehouse: bp.warehouse,
          zone: bp.zone,
          zoneName: bp.zoneName,
          aisle: bp.aisle,
          shelf: bp.shelf,
          bin: bp.bin,
          capacity: bp.capacity,
          status: bp.status,
          productCategories: bp.productCategories,
        },
      },
      upsert: false,
    },
  }));

  if (updateOps.length > 0) {
    await WarehouseLocation.bulkWrite(updateOps, { ordered: false });
  }

  const locations = await WarehouseLocation.find({ warehouse: options.warehouseCode })
    .select("_id locationCode warehouse zone zoneName aisle shelf bin capacity currentLoad status productCategories")
    .sort({ locationCode: 1 })
    .lean();

  await WarehouseConfiguration.updateOne(
    { _id: warehouseConfig._id },
    {
      $set: {
        totalLocations: locations.length,
        locationsGenerated: locations.length > 0,
        status: "ACTIVE",
        updatedBy: actor._id,
        updatedByName: actor.fullName || "System Migration",
      },
    }
  );

  return {
    expectedLocations: blueprints.length,
    insertedLocations: toInsert.length,
    removedLocations: staleLocations.length,
    updatedLocations: updateOps.length,
    locations,
  };
};

const syncInventory = async ({ locations, products, options }) => {
  if (options.skipInventorySync) {
    return {
      skipped: true,
      reason: "skip flag enabled",
    };
  }

  const variantsWithStock = products.flatMap((product) =>
    product.variants
      .map((variant) => ({
        productId: product._id,
        productName: product.name,
        typeSlug: product.resolvedTypeSlug || "accessories",
        sku: String(variant?.sku || "").trim(),
        quantity: Math.max(0, Math.floor(Number(variant?.stock) || 0)),
      }))
      .filter((item) => item.sku && item.quantity > 0)
  );

  if (options.dryRun) {
    return {
      skipped: true,
      reason: "dry-run",
      skusWithStock: variantsWithStock.length,
      totalStockUnits: variantsWithStock.reduce((sum, item) => sum + item.quantity, 0),
    };
  }

  if (!locations.length) {
    throw new Error(`No locations found for warehouse ${options.warehouseCode}`);
  }

  const activeLocations = locations
    .filter((loc) => loc.status === "ACTIVE")
    .map((loc) => ({
      _id: loc._id,
      locationCode: loc.locationCode,
      capacity: Math.max(0, Number(loc.capacity) || 0),
      currentLoad: Math.max(0, Number(loc.currentLoad) || 0),
      normalizedCategories: new Set(
        (Array.isArray(loc.productCategories) ? loc.productCategories : [])
          .map((category) => normalizeWarehouseCategory(category))
          .filter(Boolean)
      ),
    }));

  if (!activeLocations.length) {
    throw new Error(`No ACTIVE locations found for warehouse ${options.warehouseCode}`);
  }

  const locationIds = activeLocations.map((loc) => loc._id);
  let clearedRows = 0;

  if (options.resetWarehouseInventory) {
    const deleteResult = await Inventory.deleteMany({
      locationId: { $in: locationIds },
    });
    clearedRows = deleteResult.deletedCount || 0;

    await WarehouseLocation.updateMany(
      { _id: { $in: locationIds } },
      { $set: { currentLoad: 0 } }
    );

    for (const location of activeLocations) {
      location.currentLoad = 0;
    }
  }

  const poolBySlug = new Map();
  const getPool = (slug) => {
    if (poolBySlug.has(slug)) return poolBySlug.get(slug);

    const matches = activeLocations.filter(
      (location) =>
        location.normalizedCategories.size === 0 ||
        location.normalizedCategories.has(slug)
    );

    const pool = (matches.length ? matches : activeLocations).sort((a, b) =>
      a.locationCode.localeCompare(b.locationCode)
    );
    poolBySlug.set(slug, pool);
    return pool;
  };

  const placementDocs = [];
  const unplaced = [];
  let placedUnits = 0;
  let requestedUnits = 0;

  for (const item of variantsWithStock) {
    requestedUnits += item.quantity;
    let remaining = item.quantity;
    const pool = getPool(item.typeSlug || "accessories");

    while (remaining > 0) {
      const target = pool.find((location) => location.capacity - location.currentLoad > 0);
      if (!target) break;

      const available = target.capacity - target.currentLoad;
      const moveQty = Math.min(remaining, available);
      if (moveQty <= 0) break;

      placementDocs.push({
        sku: item.sku,
        productId: item.productId,
        productName: item.productName,
        locationId: target._id,
        locationCode: target.locationCode,
        quantity: moveQty,
        status: "GOOD",
      });

      target.currentLoad += moveQty;
      placedUnits += moveQty;
      remaining -= moveQty;
    }

    if (remaining > 0) {
      unplaced.push({
        sku: item.sku,
        productId: item.productId,
        productName: item.productName,
        requested: item.quantity,
        unplaced: remaining,
        typeSlug: item.typeSlug,
      });
    }
  }

  if (placementDocs.length > 0) {
    for (const chunk of chunkArray(placementDocs, 500)) {
      await Inventory.insertMany(chunk, { ordered: false });
    }
  }

  const loadUpdateOps = activeLocations.map((location) => ({
    updateOne: {
      filter: { _id: location._id },
      update: { $set: { currentLoad: location.currentLoad } },
    },
  }));

  if (loadUpdateOps.length > 0) {
    await WarehouseLocation.bulkWrite(loadUpdateOps, { ordered: false });
  }

  return {
    skipped: false,
    clearedRows,
    placementRows: placementDocs.length,
    skusWithStock: variantsWithStock.length,
    requestedUnits,
    placedUnits,
    unplacedUnits: requestedUnits - placedUnits,
    unplacedSkuCount: unplaced.length,
    unplacedPreview: unplaced.slice(0, 10),
  };
};

const printSummary = (summary) => {
  console.log(`\n${LOG_PREFIX} Summary`);
  console.log(`${LOG_PREFIX} products scanned: ${summary.productsScanned}`);
  console.log(`${LOG_PREFIX} product type updates planned: ${summary.typeUpdatesPlanned}`);
  console.log(`${LOG_PREFIX} product type updates applied: ${summary.typeUpdatesApplied}`);
  console.log(`${LOG_PREFIX} unresolved classifications: ${summary.unresolvedClassificationCount}`);
  console.log(`${LOG_PREFIX} warehouse code: ${summary.warehouseCode}`);
  console.log(`${LOG_PREFIX} zones generated: ${summary.zoneCount}`);
  console.log(`${LOG_PREFIX} expected locations: ${summary.expectedLocations}`);
  console.log(`${LOG_PREFIX} inserted locations: ${summary.insertedLocations}`);
  console.log(`${LOG_PREFIX} removed stale locations: ${summary.removedLocations}`);
  console.log(`${LOG_PREFIX} inventory sync: ${summary.inventorySyncStatus}`);

  if (summary.inventoryDetails) {
    console.log(
      `${LOG_PREFIX} inventory rows: ${summary.inventoryDetails.placementRows || 0}, requestedUnits=${summary.inventoryDetails.requestedUnits || 0}, placedUnits=${summary.inventoryDetails.placedUnits || 0}`
    );
    if ((summary.inventoryDetails.unplacedUnits || 0) > 0) {
      console.log(
        `${LOG_PREFIX} warning: unplaced units=${summary.inventoryDetails.unplacedUnits}, affected SKUs=${summary.inventoryDetails.unplacedSkuCount}`
      );
    }
  }
};

const run = async () => {
  const args = process.argv.slice(2);
  const options = parseOptions(args);

  const startedAt = Date.now();
  const summary = {
    productsScanned: 0,
    typeUpdatesPlanned: 0,
    typeUpdatesApplied: 0,
    unresolvedClassificationCount: 0,
    warehouseCode: options.warehouseCode,
    zoneCount: 0,
    expectedLocations: 0,
    insertedLocations: 0,
    removedLocations: 0,
    inventorySyncStatus: "not-started",
    inventoryDetails: null,
  };

  try {
    await connectDB();

    const typeBySlug = await loadActiveTypeMap();
    const products = await loadProducts();
    summary.productsScanned = products.length;

    const classificationPlan = planProductTypeUpdates(products, typeBySlug);
    summary.typeUpdatesPlanned = classificationPlan.updates.length;
    summary.unresolvedClassificationCount = classificationPlan.unresolved.length;

    summary.typeUpdatesApplied = await applyProductTypeUpdates(
      classificationPlan.updates,
      options.dryRun
    );

    const normalizedProducts = buildNormalizedProductSnapshot(
      products,
      classificationPlan.resolvedMetaById
    );
    const typeStats = buildTypeStats(normalizedProducts);
    const zones = buildWarehouseZones(typeStats, options);
    summary.zoneCount = zones.length;

    const actor = await resolveMigrationUser();
    const warehouseConfig = await upsertWarehouseConfig({ options, zones, actor });

    const locationSync = await syncWarehouseLocations({
      warehouseConfig: warehouseConfig || { _id: null },
      zones,
      actor,
      options,
    });
    summary.expectedLocations = locationSync.expectedLocations;
    summary.insertedLocations = locationSync.insertedLocations;
    summary.removedLocations = locationSync.removedLocations || 0;

    const inventorySummary = await syncInventory({
      locations: locationSync.locations,
      products: normalizedProducts,
      options,
    });
    summary.inventoryDetails = inventorySummary;
    summary.inventorySyncStatus = inventorySummary.skipped ? `skipped (${inventorySummary.reason})` : "completed";

    const durationMs = Date.now() - startedAt;
    printSummary(summary);
    console.log(`${LOG_PREFIX} durationMs=${durationMs}`);
  } catch (error) {
    console.error(`${LOG_PREFIX} Failed:`, error.message);
    process.exitCode = 1;
  } finally {
    await mongoose.disconnect();
    console.log(`${LOG_PREFIX} MongoDB disconnected`);
  }
};

run();
